import React, { Component } from 'react';
import PropTypes from 'prop-types';
import {
  View,
  Image,
  NativeModules,
  StyleSheet,
  Dimensions,
  PanResponder,
  Animated,
  FlatList,
  ScrollView,
} from 'react-native';
import { calculateCornerResult, msToSec } from '../utils';

const { RNTrimmerManager: TrimmerManager } = NativeModules;
const { width } = Dimensions.get('window');

const styles = StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'center'
  },
  row: {
    flexDirection: 'row',
  },
  imageItem: {
    flex: 1,
    width: 50,
    height: 50,
    resizeMode: 'cover'
  },
  corners: {
    position: 'absolute',
    height: 50,
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  rightCorner: {
    position: 'absolute',
    flex: 1,
  },
  leftCorner: {
    left: 1
  },
  bgBlack: {
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    width
  },
  cornerItem: {
    backgroundColor: 'red',
    width: 10,
    height: 50,
    padding: 5,
  }
});
export class Trimmer extends Component {
  static propTypes = {
    source: PropTypes.string.isRequired,
    onChange: PropTypes.func
  };
  static defaultProps = {
    onChange: () => null
  };

  constructor(props) {
    super(props);
    this.state = {
      images: [],
      duration: -1,
      leftCorner: new Animated.Value(0),
      rightCorner: new Animated.Value(0),
      layoutWidth: width - 100,
      num: 50,

      initWidth: 0,
      widthLeft: 0,
      initWidthR: 20,
      widthRight: 20,
      maxWidth: 50,
      xFlat: 0,
      startTime: 0,
      endTime: 15,

    };

    this.leftResponder = null;
    this.rigthResponder = null;

    this._startTime = 0;
    this._endTime = 0;
    this._handleRightCornerMove = this._handleRightCornerMove.bind(this);
    this._handleLeftCornerMove = this._handleLeftCornerMove.bind(this);
    this._retriveInfo = this._retriveInfo.bind(this);
    this._retrivePreviewImages = this._retrivePreviewImages.bind(this);
    this._handleRightCornerRelease = this._handleRightCornerRelease.bind(this);
    this._handleLeftCornerRelease = this._handleLeftCornerRelease.bind(this);
  }

  async componentWillMount() {
    // @TODO: Cleanup on unmount
    this.state.leftCorner.addListener(({ value }) => {
      this.setState({ widthLeft: value })
      this._leftCornerPos = value
    });
    this.state.rightCorner.addListener(({ value }) => {
      const { initWidthR } = this.state
      // this.setState({ widthRight: value })
      this._rightCornerPos = value
      this.setState({ widthRight: initWidthR - value > 0 ? initWidthR - value : 0 })
      // console.log(initWidthR - value )
    });

    this.leftResponder = PanResponder.create({
      onMoveShouldSetPanResponder: (e, gestureState) => Math.abs(gestureState.dx) > 0,
      onMoveShouldSetPanResponderCapture: (e, gestureState) => Math.abs(gestureState.dx) > 0,
      onPanResponderMove: this._handleLeftCornerMove,
      onPanResponderRelease: this._handleLeftCornerRelease
    });

    this.rightResponder = PanResponder.create({
      onMoveShouldSetPanResponder: (e, gestureState) => Math.abs(gestureState.dx) > 0,
      onMoveShouldSetPanResponderCapture: (e, gestureState) => Math.abs(gestureState.dx) > 0,
      onPanResponderMove: this._handleRightCornerMove,
      onPanResponderRelease: this._handleRightCornerRelease
    });
    const { source = '' } = this.props;
    if (!source.trim()) {
      throw new Error('source should be valid string');
    }
    await this._retriveInfo();
    this._retrivePreviewImages();
  }

  componentWillReceiveProps(nextProps) {
    if (nextProps.source !== this.props.source) {
      this._retrivePreviewImages();
      this._retriveInfo();
    }
  }

  componentWillUnmount() {
    this.state.leftCorner.removeAllListeners();
    this.state.rightCorner.removeAllListeners();
  }

  _handleLeftCornerRelease() {
    this.state.leftCorner.setOffset(this._leftCornerPos);
    this.state.leftCorner.setValue(0);
  }

  _handleRightCornerRelease() {
    this.state.rightCorner.setOffset(this._rightCornerPos);
    this.state.rightCorner.setValue(0);
  }

  _handleRightCornerMove(e, gestureState) {
    const { duration, layoutWidth, initWidthR, xFlat, maxWidth } = this.state;
    const leftPos = this._leftCornerPos || 0;
    const rightPos = layoutWidth - Math.abs(this._rightCornerPos);
    const inti = initWidthR - this._rightCornerPos || initWidthR;
    const moveLeft = gestureState.dx < 0;
    // console.log(rightPos - leftPos <= 50 && moveLeft)
    if (rightPos - leftPos <= 50 && moveLeft) {
      return;
    }
    this._endTime = calculateCornerResult(duration, this._rightCornerPos, layoutWidth, true);

    const endTime = (((width + xFlat) - inti) / maxWidth) * duration

    this.setState({ endTime: endTime * 1000 })

    this._callOnChange();
    Animated.event([
      null, { dx: this.state.rightCorner }
    ])(e, gestureState);
  }

  _handleLeftCornerMove(e, gestureState) {
    const { duration, layoutWidth, xFlat, maxWidth } = this.state;
    const leftPos = this._leftCornerPos;
    const rightPos = layoutWidth - Math.abs(this._rightCornerPos) || layoutWidth - 20;
    const moveRight = gestureState.dx > 0;

    // console.log(rightPos)
    if (rightPos - leftPos <= 50 && moveRight) {
      return;
    }

    // % thoi gian tren tong cua Flatlist khi keo thanh ben trai
    const startTime = ((leftPos + xFlat) / maxWidth) * duration

    this._startTime = calculateCornerResult(duration, this._leftCornerPos, layoutWidth);
    this.setState({ startTime: startTime * 1000 })
    this._callOnChange();

    Animated.event([
      null,
      { dx: this.state.leftCorner }
    ])(e, gestureState);
  }

  _callOnChange() {
    const { onChange } = this.props
    const { startTime, endTime } = this.state
    onChange(
      startTime,
      endTime
    );
  }

  _retriveInfo() {
    TrimmerManager
      .getVideoInfo(this.props.source)
      .then((info) => {
        this.setState(() => ({
          ...info,
          duration: msToSec(info.duration)
        }));
        this._endTime = msToSec(info.duration);
      });
  }

  // get ra thong tin cua slicebar: chiem 2/3 neu >15s -> time duoc chuyen ve mstoSecond (msToSec)
  _retrivePreviewImages() {
    TrimmerManager
      .getPreviewImages(this.props.source)
      .then(({ images }) => {
        const { duration } = this.state
        if (duration <= 0.015) {
          this.setState({ initWidthR: 0, num: width / images.length, endTime: duration * 1000 })
        } else {
          const mLeg = (4 / 3 * width) / images.length
          this.setState({ initWidthR: (1 / 3) * width, num: mLeg })
        }
        this.setState({ images, maxWidth: images.length * 50 });
      })
      .catch((e) => console.error(e));
  }

  renderLeftSection() {
    const { leftCorner, layoutWidth } = this.state;
    return (
      <Animated.View
        ref={(ref) => this.leftVIew = ref}
        style={[styles.container, styles.leftCorner, {
          // position: 'absolute',
          left: - layoutWidth,
          transform: [{
            translateX: leftCorner,
          }]
        }]}
        {...this.leftResponder.panHandlers}
      >
        <View style={styles.row}>
          <View style={styles.bgBlack} />
          <View style={styles.cornerItem} />
        </View>
      </Animated.View>
    );
  }

  renderRightSection() {
    const { rightCorner, layoutWidth, initWidthR } = this.state;
    return (
      <Animated.View
        style={[styles.container, styles.rightCorner, { right: -layoutWidth + initWidthR }, {
          transform: [{
            translateX: rightCorner
          }]
        }]}
        {...this.rightResponder.panHandlers}
      >
        <View style={styles.row}>
          <View style={styles.cornerItem} />
          <View style={styles.bgBlack} />
        </View>
      </Animated.View>
    )
  }

  render() {
    const { images, num } = this.state;
    const { widthLeft, maxWidth, duration, widthRight } = this.state;
    const { onChange } = this.props

    return (
      <View
        style={styles.container}
        onLayout={({ nativeEvent }) => {
          this.setState({
            layoutWidth: nativeEvent.layout.width
          });
        }}
      >
        <FlatList
          horizontal
          data={images}
          renderItem={({ item, index }) => {
            return (
              <Image
                key={`preview-source-${item}-${index}`}
                source={{ uri: item }}
                style={[styles.imageItem, { width: num }]}
              />
            )
          }}
          onScroll={(e) => {
            // console.log(e.nativeEvent)
            const { startTime, endTime } = this.state
            const xFlat = e.nativeEvent.contentOffset.x
            const perX = ((widthLeft + xFlat) / maxWidth) * duration
            const perY = (((width + xFlat) - widthRight) / maxWidth) * duration
            console.log(perX , perY)
            this.setState({
              startTime: isNaN(perX) ? startTime : perX,
              endTime: isNaN(perY) ? endTime : perY,
              xFlat
            }, () => this._callOnChange())
          }}
        />
        <View style={styles.corners}>
          {this.renderLeftSection()}
          {this.renderRightSection()}
        </View>
      </View>
    );
  }
}
